package main

import (
	"bytes"
	"compress/gzip"
	"flag"
	"fmt"
	"io/ioutil"
	"log"
	"math/rand"
	"os"
	"path/filepath"
	"strings"
)

func main() {
	var inputDir = flag.String("input-dir", "./web/static/sources/", "input directory")
	var outputFile = flag.String("output-file", "./web/static-gen.go", "output file")

	flag.Parse()

	Generate(*inputDir, *outputFile)
}

func Generate(inputDir string, outputFile string) {
	flag.Parse()

	out, err := os.Create(outputFile)
	if err != nil {
		log.Fatalf("output file create error: %v", err)
	}

	w(out, `// Code generated by generators/static/static.go
// DO NOT EDIT!

package web

import (
	"bytes"
	"compress/gzip"
	"io/ioutil"
	"net/http"
)

func init() {`)
	processDir(inputDir, inputDir, out)
	w(out, "}")

	processUnpacker(out)
}

func processDir(inputDir string, dir string, out *os.File) {
	files, err := ioutil.ReadDir(dir)
	if err != nil {
		fmt.Println(err.Error())
		os.Exit(1)
	}

	for _, f := range files {
		if f.IsDir() {
			processDir(inputDir, filepath.Join(dir, f.Name()), out)
		} else {
			processFile(inputDir, filepath.Join(dir, f.Name()), out)
		}
	}
}

func processFile(inputDir string, path string, out *os.File) {
	inputData, err := ioutil.ReadFile(path)
	if err != nil {
		fmt.Println(err.Error())
		os.Exit(1)
	}

	handler := handlerPath(path, inputDir)
	varName := fmt.Sprintf("d%v", rand.Intn(10000))

	w(out, "\n\t"+varName+" := []byte{"+packData(inputData)+"}")

	w(out, `
	staticResources = append(staticResources, staticResource{
		path: "`+handler+`",
		f: func(w http.ResponseWriter, _ *http.Request) {
			w.Header().Set("Content-Type", "`+contentType(handler)+`")
			w.WriteHeader(http.StatusOK)
			_, _ = w.Write(UnpackGzip(`+varName+`))
		},
	})`)

	if filepath.Base(handler) == "index.html" || filepath.Base(handler) == "index.htm" {
		handler = strings.TrimSuffix(handler, "/"+filepath.Base(handler))

		w(out, `
	staticResources = append(staticResources, staticResource{
		path: "`+handler+`",
		f: func(w http.ResponseWriter, _ *http.Request) {
			w.Header().Set("Content-Type", "`+contentType(handler)+`")
			w.WriteHeader(http.StatusOK)
			_, _ = w.Write(UnpackGzip(`+varName+`))
		},
	})`)
	}
}

func processUnpacker(out *os.File) {
	w(out, `
func UnpackGzip(packed []byte) []byte {
	r, err := gzip.NewReader(bytes.NewBuffer(packed))
	if err != nil {
		return []byte{}
	}

	defer func() {
		_ = r.Close()
	}()

	data, err := ioutil.ReadAll(r)
	if err != nil {
		return []byte{}
	}

	return data
}`)
}

func w(out *os.File, s string) {
	_, err := out.Write([]byte(s + "\n"))
	if err != nil {
		fmt.Println(err.Error())
		os.Exit(1)
	}
}

func handlerPath(path, trimPrefix string) string {
	path = strings.Trim(path, ".\\/")
	path = strings.Replace(path, "\\", "/", -1)

	trimPrefix = strings.Trim(trimPrefix, ".\\/")
	trimPrefix = strings.Replace(trimPrefix, "\\", "/", -1)

	path = strings.TrimPrefix(path, trimPrefix)

	path = strings.Replace(path, "\\", "/", -1)

	return path
}

func contentType(path string) string {
	switch filepath.Ext(path) {
	case ".js":
		return "application/javascript"
	case ".json":
		return "application/json"
	case ".css":
		return "text/css"
	default:
		return "text/html"
	}
}

func packData(src []byte) string {
	var b bytes.Buffer

	w, err := gzip.NewWriterLevel(&b, gzip.BestCompression)
	if err != nil {
		fmt.Println(err.Error())
		os.Exit(1)
	}

	_, err = w.Write(src)
	if err != nil {
		fmt.Println(err.Error())
		os.Exit(1)
	}

	err = w.Close()
	if err != nil {
		fmt.Println(err.Error())
		os.Exit(1)
	}

	var data []string
	for _, v := range b.Bytes() {
		data = append(data, fmt.Sprintf("%v", v))
	}

	return strings.Join(data, ",")
}
